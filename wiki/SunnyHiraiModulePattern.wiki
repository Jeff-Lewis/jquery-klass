#summary Sunny Hirai's Version of the Module Pattern

= Sunny Hirai's Module Pattern =

The purpose of this article is to show you a useful variation on the !JavaScript module pattern introduced by Douglas Crockford.

While the module pattern works well, it can be modified to increase code quality, improve readability and reduce some types of bugs.

Some problems are:

  * Ambiguity in where to place 'constructor' code (differs depending on the constructor's role)
  * Different ways to call public and private members means you have to remember the member's scope before referring to it.
  * Since public/private members are declared differently, it takes time to convert a member from public to private and visa versa. This is exasperated by the fact that you don't always know ahead of time whether a member should be public or private.
  * The pattern is not self documenting and prefers commenting
  * The pattern is a little ugly (though some like its raggedness)

=== Animal Module ===

To demonstrate the regular Module Pattern and my modified version, I've created a simple animal class. It has the following members:

  * 'name' which is private
  * 'output' a private method to output text to the user
  * 'say' a public method
  * 'howl' a public method that calls 'say'

=== Module Pattern ===

{{{
  Animal = function( name ){

    // private variables
    var name = name;

    // private functions
    function output( msg ){
      alert( msg );
    }

    // public members
    return {
      say: function( msg ){
        output( name + ': ' + msg );
      },
      howl: function( msg ){
        returnObject.say( 'awoooo... ' + msg );
      }
    };
  }
}}}

=== Sunny Hirai's Module Pattern ===

{{{

  Animal = function( name ){
    var me = {
      init: function(){
        me.name = name;
      },
      output: function( msg ){
        alert( msg );
      },
      say: function( msg ){
        me.output( me.name + ': ' + msg );
      },
      howl: function( msg ){
        me.say( 'awoooo... ' + msg );
      }
    }
    me.init();
    return { say: me.say, howl: me.howl }; // public methods
  }

  // NOTE: Nice return {} alternate below for about 200 bytes of code.
  // jQuery users could add it as a $.limitKeys plugin
  // return limitKeys( me, 'say', 'howl' )

}}}

== Differences ==

Now that you've seen the code, here are the benefits of the new module pattern.

  # *Neat:* It's nice and neat and easier to read. It's easy to see what all the methods are because they are all together and nicely formatted. The module pattern is a little more efficient (less lines of code) but the private functions are declared quite differently from the public ones.
  # *Constructor:* Where should the constructor code go in the module pattern? Is it before the public object declaration, after or both before and after. The answer is it depends on what it does. By convention, it's nice to have the constructor code at the top since it is the first thing that is done; however, what if the constructor needs to call a public method in the public object as part of its initialization? In that case, the constructor needs to go below the public object declaration. This is because the public method would otherwise not yet exist. While this isn't a big deal, as the complexity of the module grows, the harder it is to keep track of why some constructor methods are above and others below the public definition. This variation on the module pattern sidesteps all of it by defining all the members first including the constructor (which I've named 'init') and then simply executes 'me.init()'. This ensures that the 'me' object exists and all the methods exist, both public and private.
  #

Although subtle, there are several important benefits to this pattern that (a) reduces the kinds of bugs you might encounter (b) makes playing easier and (c) makes the code more readable.

  # The first declaration is the object "me".
  # The first method in "me" is "init"
  # "me.init()" is called immediately after the declaration
  # "$.limitKeys" is called during the return

== Comparison ==

Let's take a look at the same code 

  function limitKeys( source ){
    var dest = {}, key;
    for (var i=1;i<arguments.length;i++){
      key = arguments[i];
      dest[ key ] = source[ key ];
    }
    return dest;
  }